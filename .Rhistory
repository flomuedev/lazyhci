#' @param within.vars (optional) a list of within-subject variables
#' @param between.vars (optional) a list of between-subject variables
#' @param analysis_type one of "aov" or "art".
#' @param posthoc.adj the adjustment method for post-hoc tests. Defaults to "bonferroni"
#' @param anova.type the type of anova test to perform. Defaults to 3
#' @param transformation (optional) a transformation that should be applied to the data before the test.
#'
#' @export
lazy_analyze<- function(data, participant, DV, within.vars = NULL, between.vars = NULL, analysis_type=c("aov", "art"), posthoc.adj = "bonf", anova.type = 3, transformation = NULL) {
require(janitor)
if(!hasArg(analysis_type))
stop("Please provide an analysis type.")
data.clean <- janitor::clean_names(data)
participant.clean <- janitor::make_clean_names(participant)
DV.clean <- janitor::make_clean_names(DV)
within.vars.clean <- janitor::make_clean_names(within.vars)
between.vars.clean <- janitor::make_clean_names(between.vars)
data.clean <- make.factors.internal(data.clean, c(within.vars.clean, between.vars.clean, participant.clean))
result <- list()
result[["descriptives"]] <- descriptives(data.clean, DV.clean, c(within.vars.clean, between.vars.clean))
if(analysis_type == "aov") {
model <- fit_model_afex.internal(data = data.clean, participant = participant.clean, DV = DV.clean, within.vars = within.vars.clean, between.vars = between.vars.clean, anova.type = anova.type, transformation = transformation)
result[["model"]] <- model
result[["post_hoc"]] <- do.post_hoc.internal(model, model$Anova$terms[!model$Anova$terms %in% c('(Intercept)')], posthoc.adj, fct_contrasts = post_hoc.internal, fct_ip = interaction_plot.aov.internal)
result[["normality_test"]] <- check_normality(model)
if(!is.null(within.vars)) {
result[["sphericity_test"]] <- check_sphericity(model)
}
if(!is.null(between.vars)) {
result[["homogeneity_test"]] <- check_homogeneity(model)
}
}
if(analysis_type == "art") {
model <- aov_art_fit.internal(data = data.clean, DV = DV.clean, participant = participant.clean, within.vars = within.vars.clean, between.vars = between.vars.clean)
model$anova <-  anova(model$m.aov)
model$anova$eta.sq <- with(model$anova, `Sum Sq`/(`Sum Sq` + `Sum Sq.res`))
result[["model"]] <- model
result[["post_hoc"]] <- do.post_hoc.internal(model$m.lme, model$anova$Term, posthoc.adj, fct_contrasts = post_hoc.art.internal, fct_ip = interaction_plot.art.internal)
}
return(result)
}
res <- lazy_analyze(data=data.phase_2, participant = "SubjectID", DV = "CollectionDuration", within.vars = c("VisualisationType", "PosUndo", "RotUndo"), analysis_type = "aov")
res$normality_test
plot(res$normality_test)
res$normality_test
res$sphericity_test
res$normality_test
plot(res$normality_test)
t <- res$normality_test
res <- lazy_analyze(data=data.phase_2, participant = "SubjectID", DV = "CollectionDuration", within.vars = c("VisualisationType", "PosUndo", "RotUndo"), analysis_type = "aov", transformation = "log")
res$normality_test
plot(res$normality_test)
res$normality_test
summary(res$normality_test)
check_normality(res$model)
plot(check_normality(res$model))
q <- check_normality(res$model)
#' lazy_analyze
#'
#' This function conducts (non-) parametric analyzes of (multi-) factorial experiments
#' @param data the data
#' @param participant the column name of the participant identifier
#' @param DV the column name of the dependent variable
#' @param within.vars (optional) a list of within-subject variables
#' @param between.vars (optional) a list of between-subject variables
#' @param analysis_type one of "aov" or "art".
#' @param posthoc.adj the adjustment method for post-hoc tests. Defaults to "bonferroni"
#' @param anova.type the type of anova test to perform. Defaults to 3
#' @param transformation (optional) a transformation that should be applied to the data before the test.
#'
#' @export
lazy_analyze<- function(data, participant, DV, within.vars = NULL, between.vars = NULL, analysis_type=c("aov", "art"), posthoc.adj = "bonf", anova.type = 3, transformation = NULL) {
require(janitor)
if(!hasArg(analysis_type))
stop("Please provide an analysis type.")
data.clean <- janitor::clean_names(data)
participant.clean <- janitor::make_clean_names(participant)
DV.clean <- janitor::make_clean_names(DV)
within.vars.clean <- janitor::make_clean_names(within.vars)
between.vars.clean <- janitor::make_clean_names(between.vars)
data.clean <- make.factors.internal(data.clean, c(within.vars.clean, between.vars.clean, participant.clean))
result <- list()
result[["descriptives"]] <- descriptives(data.clean, DV.clean, c(within.vars.clean, between.vars.clean))
if(analysis_type == "aov") {
model <- fit_model_afex.internal(data = data.clean, participant = participant.clean, DV = DV.clean, within.vars = within.vars.clean, between.vars = between.vars.clean, anova.type = anova.type, transformation = transformation)
result[["model"]] <- model
result[["post_hoc"]] <- do.post_hoc.internal(model, model$Anova$terms[!model$Anova$terms %in% c('(Intercept)')], posthoc.adj, fct_contrasts = post_hoc.internal, fct_ip = interaction_plot.aov.internal)
result[["normality_test"]] <- check_normality(result[["model"]])
if(!is.null(within.vars)) {
result[["sphericity_test"]] <- check_sphericity(model)
}
if(!is.null(between.vars)) {
result[["homogeneity_test"]] <- check_homogeneity(model)
}
}
if(analysis_type == "art") {
model <- aov_art_fit.internal(data = data.clean, DV = DV.clean, participant = participant.clean, within.vars = within.vars.clean, between.vars = between.vars.clean)
model$anova <-  anova(model$m.aov)
model$anova$eta.sq <- with(model$anova, `Sum Sq`/(`Sum Sq` + `Sum Sq.res`))
result[["model"]] <- model
result[["post_hoc"]] <- do.post_hoc.internal(model$m.lme, model$anova$Term, posthoc.adj, fct_contrasts = post_hoc.art.internal, fct_ip = interaction_plot.art.internal)
}
return(result)
}
make.factors.internal <- function(data.clean, vars) {
for(var in vars) {
if(!is.factor(data.clean[[var]])) {
warning(paste0("auto-converting column ", var, " to a factor."))
data.clean[[var]] <- as.factor(data.clean[[var]])
}
}
return(data.clean)
}
do.post_hoc.internal <- function(model, terms, posthoc.adj = "bonf", fct_contrasts, fct_ip) {
require(tidyverse)
result <- list()
for(term in terms) {
print(unlist(str_split(term, ":")))
tmp <- fct_contrasts(model, unlist(str_split(term, ":")), posthoc.adj)
interaction.plot <- fct_ip(tmp[[1]], unlist(str_split(term, ":")))
tmp[["interaction_plot"]] <- interaction.plot
result[[term]] <- tmp
}
return(result)
}
post_hoc.art.internal <- function(model, factors, posthoc.adj = "bonf") {
artlm <- artlm.con(model, paste(factors, collapse = ":"))
result <- post_hoc.internal(artlm, factors, posthoc.adj, collapse = "")
return(result)
}
post_hoc.internal <- function(model, factors, posthoc.adj = "bonf", collapse=":") {
form_string_emm <- paste0("pairwise ~ ", paste(factors, collapse = collapse))
result <- emmeans(model, list(as.formula(form_string_emm)), adjust = "bonf")
return(result)
}
fit_model_afex.internal <- function(data, participant, DV, within.vars = NULL, between.vars = NULL, transformation = NULL, anova.type = 3, es = "ges") {
require(afex)
require(performance)
require(qqplotr)
afex_options(
correction_aov = "GG",
emmeans_model = "multivariate"
)
aov_ez_string <- "afex::aov_ez(id = participant, dv = DV, data = data, type = anova.type, include_aov = TRUE, es = es"
if(!is.null(within.vars))
aov_ez_string <- paste0(aov_ez_string, ", within = within.vars")
if(!is.null(between.vars))
aov_ez_string <- paste0(aov_ez_string, ", between = between.vars")
if(!is.null(transformation))
aov_ez_string <- paste0(aov_ez_string, ", transformation = transformation")
aov_ez_string <- paste0(aov_ez_string, ")")
message(paste0("Fitting AOV Model using afex for ", aov_ez_string))
aov.model <- eval(parse(text=aov_ez_string))
return(aov.model)
}
aov_art_fit.internal <- function(data, DV, participant, within.vars = c(), between.vars = c()) {
require(ARTool)
require(effectsize)
data.internal <- as.data.frame(data)
formula.aov <- paste(
DV,
" ~ ",
"(",
paste(c(within.vars, between.vars), collapse ="*"),
")",
" + ",
"Error(",
participant,
"/",
"(",
paste(within.vars, collapse ="*"),
"))",
sep=""
)
formula.lme <- paste(
DV,
" ~ ",
"(",
paste(c(within.vars, between.vars), collapse ="*"),
")",
" + ",
"(1|",
participant,
")",
sep=""
)
print(formula.aov)
m.aov <- art(as.formula(formula.aov), data=data)
m.lme <- art(as.formula(formula.lme), data=data)
return(list("m.aov" = m.aov, "m.lme" = m.lme))
}
interaction_plot.aov.internal <- function(emmeans_model, factors) {
if(length(factors) == 1) {
formula2 <- as.formula(paste("~", factors[[1]], sep=""))
}
if(length(factors) == 2) {
formula2 <- as.formula(paste(factors[[1]], "~", factors[[2]], sep=""))
} else if(length(factors) == 3) {
formula2 <- as.formula(paste(factors[[1]], "~", factors[[2]], " | ", factors[[3]], sep=""))
}
return(emmip(emmeans_model, formula2))
}
interaction_plot.art.internal <- function(emmeans_model, factors) {
colname <- paste(factors, collapse = "")
emmeans_model <- as.data.frame(emmeans_model) %>%
separate(!!as.name(colname), factors, sep = ",")
aes_ggplot_arguments <- list(
x=factors[[1]],
y="emmean"
)
tvar <- factors[[1]]
if(length(factors) > 1)
tvar <- factors[[2]]
plot <- ggplot(data=emmeans_model, aes_string(x=factors[[1]], y="emmean", colour = tvar)) +
geom_point() +
geom_linerange(
aes_string(ymin = "lower.CL", ymax = "upper.CL")
) +
geom_line(
aes_string(
group = tvar
)
)
if(length(factors) == 3) {
plot <- plot + facet_grid(reformulate(factors[[3]], "."))
}
return(plot)
}
res <- lazy_analyze(data=data.phase_2, participant = "SubjectID", DV = "CollectionDuration", within.vars = c("VisualisationType", "PosUndo", "RotUndo"), analysis_type = "aov", transformation = "log")
res$normality_test
t <- res$normality_test
plot(res$normality_test)
res <- lazy_analyze(data=data.phase_2, participant = "SubjectID", DV = "CollectionDuration", within.vars = c("VisualisationType", "PosUndo", "RotUndo"), analysis_type = "aov")
plot(res$normality_test)
devtools::document()
library(lazyhci)
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @param IVs a vector of the names of the grouping variables
#' @param fun.sum (optional) the summary function to use. Defaults to mean.
#' @param fun.error (optional) the error function to use. Defaults to sd.
#' @param p.scale_fill_manual (optional) a color scale for the plot
#' @param p.basesize (optional) font size of the plot
#' @param p.title (optinal) a title
#' @param theme.fontfamily (optional) a font for your plot. Must be registered using extrafont.
#' @param theme.fontfamily.device (optional) the device for extrafont. Defaults to win.
#' @param na.rm (default = false) if NAs should be removed before plotting
#' @export
data_summary_plot <- function(data, DV, IVs, fun.sum = mean, fun.error = sd, p.scale_fill_manual = NULL, p.basesize = 10, p.title = NULL, theme.fontfamily = NULL, theme.fontfamily.device = "win", na.rm = FALSE){
require(ggplot2)
ensure_font_support.internal(theme.fontfamily, theme.fontfamily.device)
if(any(length(IVs) < 1 | length(IVs) > 4) )
stop('Sorry, only 1-4 grouping variables supported')
IVs.pretty <- IVs
DV.pretty <- DV
data <- fix_col_names(data)
IVs <- fix_strings(IVs)
DV <- fix_strings(DV)
data.plot <- data_summary.internal(data, DV, IVs, fun.sum, fun.error, na.rm = na.rm)
p<- NULL
if(length(IVs) == 1)
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[1])) + xlab(IVs.pretty[1])
else
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[2])) + xlab(IVs.pretty[1]) + labs(fill = IVs.pretty[2])
if(!is.null(p.scale_fill_manual))
p <- p + scale_fill_manual(values = p.scale_fill_manual)
p <- p + geom_bar(stat="identity",
position=position_dodge2(preserve = "single")) +
geom_errorbar(aes(ymin=mean-error, ymax=mean+error), width = 0.2,
position = position_dodge2(width = 0.2, padding = 0.3, preserve = "single"))  +
ylab(DV.pretty)
if(length(IVs) == 3) {
p <- p + facet_wrap(as.formula(paste("~", IVs[3])))
}
if(length(IVs) == 4) {
p <- p + facet_grid(as.formula(paste(IVs[3], "~", IVs[4], sep=" ")))
}
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = p.basesize)
else
p <- p + theme_minimal(base_size = p.basesize)
p <- p + theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom")
if(!is.null(p.title)) {
p <- p + ggtitle(p.title)
}
return(p)
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @noRd
ensure_font_support.internal <- function(fontfamily, device="win") {
require(extrafont)
if(is.null(fontfamily))
return()
if(is.null(fonts()))
extrafont::loadfonts(device = device)
result <- fontfamily %in% fonts()
if(!result)
stop(paste0("Sorry, could not load font family ", fontfamily, ". Check spelling or run font_import() if using this the first time. If you get 'No FontName. Skipping' during font_import(), try https://stackoverflow.com/questions/61204259/how-can-i-resolve-the-no-font-name-issue-when-importing-fonts-into-r-using-ext/68642855#68642855"))
warning("You are plotting using a custom font. When exporting to PDF, make sure to use ggsave with device = cairo_pdf for the fonts to be automatically embedded.")
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @noRd
data_summary.internal <- function(data, varname, groupnames, fun.sum = mean, fun.error = sd, na.rm = FALSE){
require(dplyr)
data.sum <- data %>%
dplyr::group_by_at(groupnames) %>%
dplyr::summarise(
mean = fun.sum(!!as.name(varname), na.rm = na.rm),
error = fun.error(!!as.name(varname), na.rm = na.rm)
)
return(data.sum)
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @param IVs a vector of the names of the grouping variables
#' @param fun.sum (optional) the summary function to use. Defaults to mean.
#' @param fun.error (optional) the error function to use. Defaults to sd.
#' @param p.scale_fill_manual (optional) a color scale for the plot
#' @param p.basesize (optional) font size of the plot
#' @param p.title (optinal) a title
#' @param theme.fontfamily (optional) a font for your plot. Must be registered using extrafont.
#' @param theme.fontfamily.device (optional) the device for extrafont. Defaults to win.
#' @param na.rm (default = false) if NAs should be removed before plotting
#' @export
data_summary_plot <- function(data, DV, IVs, fun.sum = mean, fun.error = sd, p.scale_fill_manual = NULL, p.basesize = 10, p.title = NULL, theme.fontfamily = NULL, theme.fontfamily.device = "win", na.rm = FALSE){
require(ggplot2)
ensure_font_support.internal(theme.fontfamily, theme.fontfamily.device)
if(any(length(IVs) < 1 | length(IVs) > 4) )
stop('Sorry, only 1-4 grouping variables supported')
IVs.pretty <- IVs
DV.pretty <- DV
data <- fix_col_names(data)
IVs <- fix_strings(IVs)
DV <- fix_strings(DV)
data.plot <- data_summary.internal(data, DV, IVs, fun.sum, fun.error, na.rm = na.rm)
p<- NULL
if(length(IVs) == 1)
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[1])) + xlab(IVs.pretty[1])
else
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[2])) + xlab(IVs.pretty[1]) + labs(fill = IVs.pretty[2])
if(!is.null(p.scale_fill_manual))
p <- p + scale_fill_manual(values = p.scale_fill_manual)
p <- p + geom_bar(stat="identity",
position=position_dodge2(preserve = "single")) +
geom_errorbar(aes(ymin=mean-error, ymax=mean+error), width = 0.2,
position = position_dodge2(width = 0.2, padding = 0.8, preserve = "single"))  +
ylab(DV.pretty)
if(length(IVs) == 3) {
p <- p + facet_wrap(as.formula(paste("~", IVs[3])))
}
if(length(IVs) == 4) {
p <- p + facet_grid(as.formula(paste(IVs[3], "~", IVs[4], sep=" ")))
}
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = p.basesize)
else
p <- p + theme_minimal(base_size = p.basesize)
p <- p + theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom")
if(!is.null(p.title)) {
p <- p + ggtitle(p.title)
}
return(p)
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @param IVs a vector of the names of the grouping variables
#' @param fun.sum (optional) the summary function to use. Defaults to mean.
#' @param fun.error (optional) the error function to use. Defaults to sd.
#' @param p.scale_fill_manual (optional) a color scale for the plot
#' @param p.basesize (optional) font size of the plot
#' @param p.title (optinal) a title
#' @param theme.fontfamily (optional) a font for your plot. Must be registered using extrafont.
#' @param theme.fontfamily.device (optional) the device for extrafont. Defaults to win.
#' @param na.rm (default = false) if NAs should be removed before plotting
#' @export
data_summary_plot <- function(data, DV, IVs, fun.sum = mean, fun.error = sd, p.scale_fill_manual = NULL, p.basesize = 10, p.title = NULL, theme.fontfamily = NULL, theme.fontfamily.device = "win", na.rm = FALSE){
require(ggplot2)
ensure_font_support.internal(theme.fontfamily, theme.fontfamily.device)
if(any(length(IVs) < 1 | length(IVs) > 4) )
stop('Sorry, only 1-4 grouping variables supported')
IVs.pretty <- IVs
DV.pretty <- DV
data <- fix_col_names(data)
IVs <- fix_strings(IVs)
DV <- fix_strings(DV)
data.plot <- data_summary.internal(data, DV, IVs, fun.sum, fun.error, na.rm = na.rm)
p<- NULL
if(length(IVs) == 1)
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[1])) + xlab(IVs.pretty[1])
else
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[2])) + xlab(IVs.pretty[1]) + labs(fill = IVs.pretty[2])
if(!is.null(p.scale_fill_manual))
p <- p + scale_fill_manual(values = p.scale_fill_manual)
p <- p + geom_bar(stat="identity",
position=position_dodge2(preserve = "single")) +
geom_errorbar(aes(ymin=mean-error, ymax=mean+error), width = 0.2,
position = position_dodge2(width = 0.2, padding = 0.8))  +
ylab(DV.pretty)
if(length(IVs) == 3) {
p <- p + facet_wrap(as.formula(paste("~", IVs[3])))
}
if(length(IVs) == 4) {
p <- p + facet_grid(as.formula(paste(IVs[3], "~", IVs[4], sep=" ")))
}
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = p.basesize)
else
p <- p + theme_minimal(base_size = p.basesize)
p <- p + theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom")
if(!is.null(p.title)) {
p <- p + ggtitle(p.title)
}
return(p)
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @param IVs a vector of the names of the grouping variables
#' @param fun.sum (optional) the summary function to use. Defaults to mean.
#' @param fun.error (optional) the error function to use. Defaults to sd.
#' @param p.scale_fill_manual (optional) a color scale for the plot
#' @param p.basesize (optional) font size of the plot
#' @param p.title (optinal) a title
#' @param theme.fontfamily (optional) a font for your plot. Must be registered using extrafont.
#' @param theme.fontfamily.device (optional) the device for extrafont. Defaults to win.
#' @param na.rm (default = false) if NAs should be removed before plotting
#' @export
data_summary_plot <- function(data, DV, IVs, fun.sum = mean, fun.error = sd, p.scale_fill_manual = NULL, p.basesize = 10, p.title = NULL, theme.fontfamily = NULL, theme.fontfamily.device = "win", na.rm = FALSE){
require(ggplot2)
ensure_font_support.internal(theme.fontfamily, theme.fontfamily.device)
if(any(length(IVs) < 1 | length(IVs) > 4) )
stop('Sorry, only 1-4 grouping variables supported')
IVs.pretty <- IVs
DV.pretty <- DV
data <- fix_col_names(data)
IVs <- fix_strings(IVs)
DV <- fix_strings(DV)
data.plot <- data_summary.internal(data, DV, IVs, fun.sum, fun.error, na.rm = na.rm)
p<- NULL
if(length(IVs) == 1)
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[1])) + xlab(IVs.pretty[1])
else
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[2])) + xlab(IVs.pretty[1]) + labs(fill = IVs.pretty[2])
if(!is.null(p.scale_fill_manual))
p <- p + scale_fill_manual(values = p.scale_fill_manual)
p <- p + geom_bar(stat="identity",
position=position_dodge2(preserve = "single")) +
geom_errorbar(aes(ymin=mean-error, ymax=mean+error), width = 0.2,
position = position_dodge2(width = 0.5, padding = 0.5))  +
ylab(DV.pretty)
if(length(IVs) == 3) {
p <- p + facet_wrap(as.formula(paste("~", IVs[3])))
}
if(length(IVs) == 4) {
p <- p + facet_grid(as.formula(paste(IVs[3], "~", IVs[4], sep=" ")))
}
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = p.basesize)
else
p <- p + theme_minimal(base_size = p.basesize)
p <- p + theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom")
if(!is.null(p.title)) {
p <- p + ggtitle(p.title)
}
return(p)
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
#' @param IVs a vector of the names of the grouping variables
#' @param fun.sum (optional) the summary function to use. Defaults to mean.
#' @param fun.error (optional) the error function to use. Defaults to sd.
#' @param p.scale_fill_manual (optional) a color scale for the plot
#' @param p.basesize (optional) font size of the plot
#' @param p.title (optinal) a title
#' @param theme.fontfamily (optional) a font for your plot. Must be registered using extrafont.
#' @param theme.fontfamily.device (optional) the device for extrafont. Defaults to win.
#' @param na.rm (default = false) if NAs should be removed before plotting
#' @export
data_summary_plot <- function(data, DV, IVs, fun.sum = mean, fun.error = sd, p.scale_fill_manual = NULL, p.basesize = 10, p.title = NULL, theme.fontfamily = NULL, theme.fontfamily.device = "win", na.rm = FALSE){
require(ggplot2)
ensure_font_support.internal(theme.fontfamily, theme.fontfamily.device)
if(any(length(IVs) < 1 | length(IVs) > 4) )
stop('Sorry, only 1-4 grouping variables supported')
IVs.pretty <- IVs
DV.pretty <- DV
data <- fix_col_names(data)
IVs <- fix_strings(IVs)
DV <- fix_strings(DV)
data.plot <- data_summary.internal(data, DV, IVs, fun.sum, fun.error, na.rm = na.rm)
p<- NULL
if(length(IVs) == 1)
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[1])) + xlab(IVs.pretty[1])
else
p<- ggplot(data.plot, aes_string(x=IVs[1], y="mean", fill=IVs[2])) + xlab(IVs.pretty[1]) + labs(fill = IVs.pretty[2])
if(!is.null(p.scale_fill_manual))
p <- p + scale_fill_manual(values = p.scale_fill_manual)
p <- p + geom_bar(stat="identity",
position=position_dodge(preserve = "single")) +
geom_errorbar(aes(ymin=mean-error, ymax=mean+error), width = 0.2,
position = position_dodge(width = 0.9, preserve = "single"))  +
ylab(DV.pretty)
if(length(IVs) == 3) {
p <- p + facet_wrap(as.formula(paste("~", IVs[3])))
}
if(length(IVs) == 4) {
p <- p + facet_grid(as.formula(paste(IVs[3], "~", IVs[4], sep=" ")))
}
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = p.basesize)
else
p <- p + theme_minimal(base_size = p.basesize)
p <- p + theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom")
if(!is.null(p.title)) {
p <- p + ggtitle(p.title)
}
return(p)
}
data_summary_plot(data=data.phase_2, DV = "CollectionDuration", IVs = c("VisualisationType", "PosUndo", "RotUndo"))
