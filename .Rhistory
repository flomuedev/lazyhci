if(!result)
warning(paste0("Sorry, could not load font family ", fontfamily, ". Check spelling or run font_import() if using this the first time. If you get 'No FontName. Skipping' during font_import(), try https://stackoverflow.com/questions/61204259/how-can-i-resolve-the-no-font-name-issue-when-importing-fonts-into-r-using-ext/68642855#68642855"))
return(result)
}
check_font_support("Pristinas")
#+++++++++++++++++++++++++
# Function to calculate the mean and the standard deviation
# for each group
#+++++++++++++++++++++++++
# data : a data frame
# varname : the name of a column containing the variable
#to be summariezed
# groupnames : vector of column names to be used as
# grouping variables
data_summary <- function(data, varname, groupnames, fun.error = sd){
require(plyr)
summary_func <- function(x, col){
c(mean = mean(x[[col]], na.rm=TRUE),
#sd = ifelse(is.logical(x[[col]]), NA, sd(x[[col]], na.rm=TRUE)))
error = fun.error(x[[col]], na.rm=TRUE))
}
data_sum<-ddply(data, groupnames, .fun=summary_func,
varname)
#data_sum <- rename(data_sum, c("mean" = varname))
return(data_sum)
}
se <- function(x, na.rm=FALSE) {
#return(sd(x, na.rm=na.rm)/sqrt(length(x)))
return(sd(x, na.rm=na.rm)/sqrt(ifelse(na.rm, length(x[!is.na(x)]), length(x))))
}
sane_shapiro_test <- function(x){
if(length(unique(x)) < 3) {
return(1.0)
} else {
return(shapiro.test(x)$p)
}
}
descriptives <- function(data, IVs, participantCol, DVcols, na.rm=TRUE) {
library(sets)
IVs.sets <- set_power(IVs)
detach("package:sets", unload=TRUE)
result = list()
for(set in IVs.sets) {
if(length(set) > 0) {
set.name <- paste(unlist(set), collapse = "_")
data.set <- data %>%
dplyr::group_by_at(unlist(set), .drop=FALSE) %>%
dplyr::summarise(
across(colnames(data)[DVcols], list(mean = mean, sd = sd, se=se, min = min, max = max), na.rm = na.rm),
n= n()
)
result[[set.name]] <- data.set
}
}
return(result)
}
art_posthoc <- function(m, effect, adj = "holm") {
res <- art.con(m, effect, adjust=adj) %>%  # run ART-C for X1 Ã— X2
summary() %>%  # add significance stars to the output
mutate(sig. = symnum(p.value, corr=FALSE, na=FALSE,
cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
symbols = c("***", "**", "*", ".", " ")))
return(res)
}
art_analysis <- function(data, IVs, participantCol, DVcols, posthoc.adj="bonferroni", outputfile=NULL) {
require(ARTool)
if(!is.null(outputfile))
sink(outputfile)
data.art <- data
for (i in DVcols) {
question <- names(data.art)[i]
data.art[,"Q"] <- data.art[i]
writeLines(paste("Performing ART Anova for IV ", question, "...", sep=""))
m <- art(as.formula(paste("Q ~ ", paste(IVs, collapse = " * "), " + (1|", participantCol, ")", sep="")), data = as.data.frame(data.art))
ano <- anova(m)
print(ano)
writeLines("Post-hoc Tests\n")
for (row in 1:nrow(ano)) {
cur.term <- ano[row, 1]
cur.p <- ano[row, 5]
if(cur.p < 0.05) {
writeLines(paste("Post-Hoc tests for ", cur.term, "\n", sep=""))
ano.posthoc <- art_posthoc(m, cur.term, posthoc.adj)
print(ano.posthoc)
writeLines("\n")
}
}
data.art$Q <- NULL
}
if(!is.null(outputfile))
sink()
}
filter_broken_participants <- function(data, IVs, participantCol, DV) {
require(dplyr)
broken <- broken_participants(data, IVs, participantCol, DV)
data.res <- data %>% filter(!(!!as.name(participantCol)) %in% unlist(broken))
data.res[[participantCol]] <- factor(data.res[[participantCol]])
return(data.res)
}
broken_participants <- function(data, IVs, participantCol, DV) {
require(dplyr)
data.sum <- data %>%
dplyr::group_by_at(c(IVs, participantCol), .drop=FALSE) %>%
dplyr::summarise(
n = n(),
val = mean(!!as.name(DV))
)
missing <- data.sum %>%
filter(n == 0)
return(unique(missing %>% ungroup %>% select(!!as.name(participantCol))))
}
check_complete_design <- function(data, IVs, participantCol, DV) {
require(dplyr)
data.sum <- data %>%
dplyr::group_by_at(c(IVs, participantCol), .drop=FALSE) %>%
dplyr::summarise(
n = n(),
val = mean(!!as.name(DV))
)
missing <- data.sum %>%
filter(n == 0)
higher <- data.sum %>%
filter(n > 1)
na.nan <- data.sum %>%
filter(is.na(val) || is.nan(val))
if(nrow(missing) != 0) {
print("This is not a complete design, go and yell at the student. The following condition data is missing:")
print("")
print(as.data.frame(missing))
return(FALSE)
}
if(nrow(na.nan) != 0) {
print("There are NAs or NANs in the table, go and yell at the student. The following conditions contain NAs or NANs:")
print("")
print(na.nan)
return(FALSE)
}
if(nrow(higher) != 0) {
print("WARNING: Your data seems to contain multiple repetitions. The table should be collapsed before the ANOVA. The following conditions contain replicated data:")
print("")
print(higher)
}
return(TRUE)
}
build_aov_latex <- function(Effect, DFn, DFd, F, p, ges) {
F <- roundp(F, digits = 2)
ges <- roundp(ges, digits = 2)
sig <- symnum(p, corr=FALSE, na=FALSE,
cutpoints = c(0, 0.001, 0.01, 0.05, 1),
symbols = c("<.001", "<.01", "<.05", ">.05"))
latexString <- paste0("\anova{", DFn, "}{", DFd, "}{",F,"}{",sig,"}{",ges,"}")
return(latexString)
}
clean_outliers <- function(data, IVs, participantCol, DV) {
require(dplyr)
dat <- data %>%
dplyr::group_by_at(c(IVs, participantCol)) %>%
mutate(clean = markt_outliers_ipq(!!as.name(DV)))
return(dat)
}
markt_outliers_ipq <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
return(y)
}
aov2_analysis <- function(data, IVs, participantCol, DVcols, posthoc.adj="bonferroni", outputfile=NULL, anova.type = 2) {
require(ez)
require(broom)
options(width = 160)
if(!is.null(outputfile))
sink(outputfile)
data.aov <- data
for (i in DVcols) {
dv <- names(data.aov)[i]
data.aov[,"Q"] <- data.aov[i]
writeLines(paste("Performing Anova for IV ", dv, "...", sep=""))
if(check_complete_design(data.aov, IVs = IVs, participantCol = participantCol, dv)) {
ezString <- paste0('ezANOVA(data=data.aov,
dv=', dv,',
wid=', participantCol, ',
within=.(', paste(IVs, collapse = ",") ,'),
type=', anova.type, ',
return_aov = TRUE)')
aov.result <- eval(parse(text=ezString))
tibble <- as_tibble(aov.result$ANOVA) %>%
mutate(latex=build_aov_latex(Effect, DFn, DFd, F, p, ges))
print(as.data.frame(tibble))
writeLines("\nPost-hoc tests\n")
tidy <- tidy(aov.result$aov)
for(row in 1:nrow(tidy)) {
cur.term <- tidy[row, 2][[1]]
cur.p <- tidy[row, 7][[1]]
if(!is.na(cur.p) && cur.p< 0.05) {
print(paste("Post-Hoc tests for ", cur.term, sep=""))
cur.formula.str <- paste("~ ", cur.term, sep="")
data.sum <- data.aov %>%
group_by_at(str_split(cur.term, pattern = ":", simplify = TRUE)) %>%
summarise(
n=n(),
mean=mean(Q, na.rm = TRUE),
sd = sd(Q, na.rm = TRUE)
)
data.sum <- data.sum %>%
mutate(latex=paste0("\val{", roundp(mean, digits = 2) ,"}{", roundp(sd, digits = 2) ,"}"))
emm <- emmeans(aov.result$aov, as.formula(cur.formula.str))
pairs <- pairs(emm,adjust = posthoc.adj)
writeLines("\nDescriptives\n")
print(as.data.frame(data.sum))
writeLines("\nEMMeans\n")
print(emm)
writeLines("\nContrasts\n")
print(pairs)
writeLines("\n")
}
}
}
}
if(!is.null(outputfile))
sink()
}
roundp <- function(x, digits = 2) {
return(sprintf(paste0("%.", digits, "f"), round(x,digits)))
}
aov_analysis <- function(data, IVs, participantCol, DVcols, posthoc.adj="bonferroni", outputfile=NULL) {
require(broom)
require(emmeans)
options(contrasts = c("contr.sum", "contr.poly"))
if(!is.null(outputfile))
sink(outputfile)
data.aov <- data
for (i in DVcols) {
question <- names(data.aov)[i]
data.aov[,"Q"] <- data.aov[i]
writeLines(paste("Performing Anova for IV ", question, "...", sep=""))
IVs.collapsed <- paste(IVs, collapse = " * ")
aov <- aov(
as.formula(
paste(
"Q ~ ", IVs.collapsed, " + Error(", participantCol, " / (", IVs.collapsed, "))",
sep="")
),
data = data.aov
)
print(summary(aov))
writeLines("\n")
tidy <- tidy(aov)
for(row in 1:nrow(tidy)) {
cur.term <- tidy[row, 2][[1]]
cur.p <- tidy[row, 7][[1]]
if(!is.na(cur.p) && cur.p< 0.05) {
print(paste("Post-Hoc tests for ", cur.term, sep=""))
cur.formula.str <- paste("~ ", cur.term, sep="")
data.sum <- data.aov %>%
group_by_at(str_split(cur.term, pattern = ":", simplify = TRUE)) %>%
summarise(
n=n(),
mean=mean(Q, na.rm = TRUE),
sd = sd(Q, na.rm = TRUE)
)
emm <- emmeans(aov, as.formula(cur.formula.str))
pairs <- pairs(emm,adjust = posthoc.adj)
emm %>% summary() %>%  # add significance stars to the output
mutate(sig. = symnum(p.value, corr=FALSE, na=FALSE,
cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
symbols = c("***", "**", "*", ".", " ")))
writeLines("\nDescriptives\n")
print(as.data.frame(data.sum))
writeLines("\nEMMeans\n")
print(emm)
writeLines("\nContrasts\n")
print(pairs)
writeLines("\n")
}
}
#aov(Q ~ toes*posture*granularity*direction*targetID
#  + Error(participant / (toes*posture*granularity*direction*targetID)),
#  data = data.tidy)
data.aov[,"Q"] <- NULL
}
if(!is.null(outputfile))
sink()
}
ensure_font_support <- function(fontfamily, device="win") {
library(extrafont)
if(is.null(fonts()))
loadfonts(device = device)
result <- fontfamily %in% fonts()
if(!result)
stop(paste0("Sorry, could not load font family ", fontfamily, ". Check spelling or run font_import() if using this the first time. If you get 'No FontName. Skipping' during font_import(), try https://stackoverflow.com/questions/61204259/how-can-i-resolve-the-no-font-name-issue-when-importing-fonts-into-r-using-ext/68642855#68642855"))
warning("You are plotting using a custom font. When exporting to PDF, make sure to use ggsave with device = cairo_pdf for the fonts to be automatically embedded.")
}
plot_likert <- function(likert.model, title, yblank=FALSE, ordered = FALSE, colorscale=NULL, theme.basesize = 19, percentagelabel = FALSE, theme.fontfamily = NULL, theme.fontfamily.device = "win") {
ensure_font_support(theme.fontfamily, theme.fontfamily.device)
if(!is.null(colorscale))
p <- plot(likert.model, ordered = ordered, colors=colorscale)
else
p <- plot(likert.model, ordered = ordered)
p <- p + ggtitle(title)
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = theme.basesize)
else
p <- p + theme_minimal(base_size = theme.basesize)
p <- p +  theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom") + guides(fill = guide_legend(nrow = 1))
if(yblank)
p <- p + theme(axis.text.y = element_blank())
if(!percentagelabel) {
p <- p + theme(axis.title.x = element_blank())
}
return(p)
}
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {
require(grid)
require(gridExtra)
plots <- list(...)
position <- match.arg(position)
g <- ggplotGrob(plots[[1]] + guides(colour = guide_legend(nrow = 1)) + theme(legend.position = position))$grobs
legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
lheight <- sum(legend$height)
lwidth <- sum(legend$width)
gl <- lapply(plots, function(x) x + theme(legend.position="none"))
gl <- c(gl, ncol = ncol, nrow = nrow)
combined <- switch(position,
"bottom" = arrangeGrob(do.call(arrangeGrob, gl),
legend,
ncol = 1,
heights = unit.c(unit(1, "npc") - lheight, lheight)),
"right" = arrangeGrob(do.call(arrangeGrob, gl),
legend,
ncol = 2,
widths = unit.c(unit(1, "npc") - lwidth, lwidth)))
grid.newpage()
grid.draw(combined)
# return gtable invisibly
invisible(combined)
}
likert_plot_model <- function(data, DVcol, IVs, grouping = NULL, drop = NULL, participantCol, survey_vector = c("strongly disagree", "disagree", "somewhat disagree", "neutral", "somewhat agree", "agree", "strongly agree")) {
require(likert)
require(reshape2)
data.plot <- as.data.frame(data)
data.plot$Q <- data.plot[,DVcol]
formulaString <- participantCol
IVs.rest <- IVs
startFactorCol <- 2
grouping.merged <- NULL
if(!is.null(c(grouping, drop))) {
grouping.col <- paste0(c(grouping, drop), collapse = " + ")
formulaString <- paste0(formulaString, " + ", grouping.col)
IVs.rest <- IVs[!IVs %in% c(grouping, drop)]
startFactorCol <- startFactorCol + length(c(grouping, drop))
}
formulaString <- paste0(formulaString, " ~ ")
IVs.rest.col <- paste(IVs.rest, collapse = " + ")
formulaString <- paste0(formulaString, IVs.rest.col)
print(paste("Building Likert model for DV ", colnames(data)[DVcol], " with ", formulaString, sep=""))
data.likert <- reshape2::dcast(data.plot, as.formula(formulaString), value.var = "Q")
for(factorCol in startFactorCol:ncol(data.likert)) {
data.likert[,factorCol] <- factor(data.likert[,factorCol], levels = seq(1:length(survey_vector)), labels = survey_vector)
}
if(!is.null(grouping)) {
groupingColName <- paste(grouping, collapse = "x")
grouping.cols <- data.likert %>% select(one_of(grouping))
grouping.merged <- grouping.cols %>% unite("grouping", 1:ncol(.), sep=", ", remove = FALSE)
}
startCol <- length(c(grouping, drop)) + 2
likert <- likert(data.likert[,startCol:ncol(data.likert)], grouping = grouping.merged$grouping)
return(likert)
}
data_summary_plot_all <- function(data, varnames, groupnames, outdir, prefix, p.width, p.height, fun.error = sd,  scale_fill_manual = NULL) {
dir.create(outdir)
library(sets)
groupnames.sets <- set_power(groupnames)
detach("package:sets", unload=TRUE)
for(set in groupnames.sets) {
set <- unlist(set)
if(any(length(set) < 1 | length(set) > 4) ) {
message("Sorry, I don't know how to handle the set.")
} else {
data_summary_plot_multiple(data, varnames, set, outdir, prefix, p.width, p.height, fun.error, scale_fill_manual)
}
}
library(qpdf)
#qpdf::pdf_combine(input = c("file.pdf", "file2.pdf", "file3.pdf"),
#output = "output.pdf")
#list.files(outdir, pattern = "^tictactoes.*pdf$")
files <- list.files(outdir, pattern = paste("^", prefix, ".*pdf$", sep=""))
cur.wd <- getwd()
setwd(outdir)
qpdf::pdf_combine(input = files,
output = "summary.pdf")
setwd(cur.wd)
}
data_summary_plot_multiple <- function(data, varnames, groupnames, outdir, prefix, p.width, p.height, fun.error = sd,  scale_fill_manual = NULL) {
groupingString <- paste("_by", paste(groupnames, collapse="_"), sep="_")
for(varname in varnames) {
title <- paste(prefix, "_", varname, groupingString, sep="")
p <- data_summary_plot(data, varname, groupnames, fun.error, scale_fill_manual, p.title = title)
filename = paste(title, ".pdf", sep="")
outPath = file.path(outdir, filename)
print(outPath)
if(any(missing(p.width) | missing(p.height)))
ggsave(outPath, plot=p, device = cairo_pdf)
else
ggsave(outPath, plot=p, device = cairo_pdf, width = p.width, height = p.height)
}
}
data_summary_plot <- function(data, varname, groupnames, fun.error = sd, p.scale_fill_manual = NULL, p.basesize = 10, p.title = NULL, theme.fontfamily = NULL, theme.fontfamily.device = "win"){
ensure_font_support(theme.fontfamily, theme.fontfamily.device)
if(any(length(groupnames) < 1 | length(groupnames) > 4) )
stop('Sorry, only 1-4 grouping variables supported')
require(ggplot2)
data.plot <- data_summary(data, varname, groupnames, fun.error)
p<- NULL
if(length(groupnames) == 1)
p<- ggplot(data.plot, aes_string(x=groupnames[1], y="mean", fill=groupnames[1]))
else
p<- ggplot(data.plot, aes_string(x=groupnames[1], y="mean", fill=groupnames[2]))
if(!is.null(p.scale_fill_manual))
p <- p + scale_fill_manual(values = p.scale_fill_manual)
p <- p + geom_bar(stat="identity",
position=position_dodge()) +
geom_errorbar(aes(ymin=mean-error, ymax=mean+error), width=.2,
position=position_dodge(.9))  +
ylab(varname)
if(length(groupnames) == 3) {
p <- p + facet_wrap(as.formula(paste("~", groupnames[3])))
}
if(length(groupnames) == 4) {
p <- p + facet_grid(as.formula(paste(groupnames[3], "~", groupnames[4], sep=" ")))
}
if(!is.null(theme.fontfamily))
p <- p + theme_minimal(base_family = theme.fontfamily, base_size = p.basesize)
else
p <- p + theme_minimal(base_size = p.basesize)
p <- p + theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position="bottom")
if(!is.null(p.title)) {
p <- p + ggtitle(p.title)
}
return(p)
}
reshape_to_wide_all <- function(data, varnames, groupnames, ParticipantColName, outdir, prefix){
dir.create(outdir)
library(sets)
groupnames.sets <- set_power(groupnames)
detach("package:sets", unload=TRUE)
for(set in groupnames.sets) {
set <- unlist(set)
if(any(length(set) < 1) ) {
message("Sorry, I don't know how to handle the set.")
} else {
reshaped <- reshape_to_wide(data, varnames, set, ParticipantColName)
groupingString <- paste("_by", paste(set, collapse="_"), sep="_")
varnamesString <- paste(varnames, collapse="_")
filename = paste(prefix, "_", varnamesString, "_", groupingString, "_wide.csv", sep="")
outPath = file.path(outdir, filename)
write.csv(reshaped, file=outPath)
}
}
}
reshape_to_wide <- function(data, IVs, groupnames, ParticipantColName){
require(data.table)
data.wide <- data.table::dcast(setDT(data), formula = as.formula(paste(ParticipantColName, "~",  paste(groupnames, collapse="+"))), value.var = IVs, fun.aggregate = mean, na.rm = TRUE)
return(data.wide)
}
rbind_create <- function(data, row) {
if(is.null(data))
data <- row
else
data <- rbind(data, row)
return(data)
}
check_font_support("Pristinas")
ensure_font_support("Pristinas")
ensure_font_support("Pristina")
library("devtools")
install.packages(c("bayestestR", "datawizard", "Exact", "insight", "openssl", "Rttf2pt1"))
install_github("neuropsychology/psycho.R")
library("psycho")
install.packages("remotes")
install.packages("remotes")
remotes::install_github("easystats/report")
library(tidyverse)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
raw_data_folder <- "raw"
data.questionnaire <- NULL
for(file in list.files(file.path(getwd(), raw_data_folder, "questionnaire"), pattern = "*.csv$")) {
data.file <- read_csv2(file.path(getwd(), raw_data_folder, "questionnaire", file))
parts <- str_split(data.file$Condition, "_", simplify = TRUE)
data.file$toes <- as.factor(parts[,1])
data.file$posture <- as.factor(parts[,2])
data.file$granularity <- as.factor(parts[,3])
data.file$direction <- as.factor(parts[,4])
data.file$foot <- as.factor(parts[,5])
data.questionnaire <- rbind(data.questionnaire, data.file)
}
library(summarize)
data_summary_plot_all(data.questionnaire, varnames = colnames(data.questionnaire[3:4]), groupnames = c("toes", "direction", "posture"), outdir = "plots")
data_summary_plot_all(data.questionnaire, varnames = colnames(data.questionnaire[3:4]), groupnames = c("toes", "direction", "posture"), outdir = "plots", prefix = "test")
setwd_to_clipboard <- function() {
setwd(chartr("\\", "/", readClipboard()))
}
setwd_to_clipboard()
setwd("..")
getwd()
library(devtools)
document()
library(roxygen2)
setwd_to_clipboard()
setwd_to_clipboard()
document()
